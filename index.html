<!DOCTYPE html>
<!--
Copyright (c) 2020 Brian Kircher - All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1,
                                   user-scalable=no">
    <title>
      Open Loop
    </title>
    <link rel="shortcut icon" type="image/png" href="images/sim.png"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"
          integrity="sha512-5A8nwdMOWrSz20fDsjczgUidUBR8liPYU+WymTZP1lmY9G6Oc7HlZv156XqnsgNUzTyMefFTcsFH/tnJE/+xBg=="
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"
            integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.18/paper-full.min.js"
            integrity="sha512-qaPSGmKTwpu5ChwJ6AD3w7ecS3yM7pFC1cS3IfnjPM67dhXoymEomk1wqiZEHUFO4dQO1bhjo8LYImVDSDfR1g=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="text/paperscript" canvas="canvas">
      var assets =
      {
        robot: new function()
        {
          var body = new Path.Rectangle(new Rectangle([-50, -50], [100, 100]),
                                        [5, 5]);
          body.fillColor = "#dce3e9";
          body.strokeColor = "black";

          var leftWheel = new Path.Rectangle(new Rectangle([-55, -35],
                                                           [10, 70]), [5, 5]);
          leftWheel.fillColor = "#8cfbfc";
          leftWheel.strokeColor = "black";

          var rightWheel = new Path.Rectangle(new Rectangle([45, -35],
                                                            [10, 70]), [5, 5]);
          rightWheel.fillColor = "#8cfbfc";
          rightWheel.strokeColor = "black";

          var leftSensor = new Path.Circle([-25, -50], 10);
          leftSensor.fillColor = "white";
          leftSensor.strokeColor = "black";

          var rightSensor = new Path.Circle([25, -50], 10);
          rightSensor.fillColor = "white";
          rightSensor.strokeColor = "black";

          var backSensor = new Path.Circle([0, 50], 10);

          var robot = new Group(body, leftWheel, rightWheel, leftSensor,
                                rightSensor, backSensor);
          robot.visible = false;

          return(robot);
        }
      };

      var Field = new function()
      {
        var grid = new Group();

        for(var i = -3000; i <= 3000; i += 200)
        {
          var marker = new Path.Line(-3000, i, 3000, i);
          marker.strokeColor = "#cccccc";
          grid.addChild(marker);
          marker = new Path.Line(i, -3000, i, 3000);
          marker.strokeColor = "#cccccc";
          grid.addChild(marker);
        }

        var path = new Path();
        path.closed = false;
        path.add([-15, 0]);
        path.add([-15, -2000]);
        path.add([60, -2400]);
        path.add([60, -3200]);
        path.add([-15, -3600]);
        path.add([-15, -4400]);
        path.add([-90, -4800]);
        path.add([-90, -5600]);
        path.add([-15, -6000]);
        path.add([-15, -6800]);
        path.arcTo([15, -7000], [105, -7200]);
        path.arcTo([195, -7400], [225, -7600]);
        path.add([225, -8000]);
        path.arcTo([195, -8200], [105, -8400]);
        path.arcTo([15, -8600], [-15, -8800]);
        path.add([-15, -9600]);
        path.arcTo([-45, -9800], [-135, -10000]);
        path.arcTo([-225, -10200], [-255, -10400]);
        path.add([-255, -10800]);
        path.arcTo([-225, -11000], [-135, -11200]);
        path.arcTo([-45, -11400], [-15, -11600]);
        path.add([-15, -12400]);
        path.arcTo([-45, -12600], [-135, -12800]);
        path.arcTo([0, -13050], [135, -12800]);
        path.arcTo([45, -12600], [15, -12400]);
        path.add([15, -11600]);
        path.arcTo([-15, -11400], [-105, -11200]);
        path.arcTo([-195, -11000], [-225, -10800]);
        path.add([-225, -10400]);
        path.arcTo([-195, -10200], [-105, -10000]);
        path.arcTo([-15, -9800], [15, -9600]);
        path.add([15, -8800]);
        path.arcTo([45, -8600], [135, -8400]);
        path.arcTo([225, -8200], [255, -8000]);
        path.add([255, -7600]);
        path.arcTo([225, -7400], [135, -7200]);
        path.arcTo([45, -7000], [15, -6800]);
        path.add([15, -6000]);
        path.add([-60, -5600]);
        path.add([-60, -4800]);
        path.add([15, -4400]);
        path.add([15, -3600]);
        path.add([90, -3200]);
        path.add([90, -2400]);
        path.add([15, -2000]);
        path.add([15, 800]);
        path.arcTo([45, 1000], [135, 1200]);
        path.arcTo([0, 1450], [-135, 1200]);
        path.arcTo([-45, 1000], [-15, 800]);
        path.add([-15, 0]);
        path.fillColor = "black";
        path.strokeColor = "black";
        path.visible = false;

        return {
          grid: grid,
          path: path,

          reset: function()
          {
            var viewBounds = view.bounds;
            var itemBounds = this.path.bounds;

            this.path.position = viewBounds.center;
            this.path.position.y -= (itemBounds.height / 2) - 1400;

            if((globals.mode === "line") || (globals.mode === "line2") ||
               (globals.mode === "line3"))
            {
              this.path.visible = true;
            }
            else
            {
              this.path.visible = false;
            }

            this.grid.position = viewBounds.center;
          },

          resize: function()
          {
            position = Robot.position();

            this.move(view.bounds.center.x - position.x,
                      view.bounds.center.y - position.y);
          },

          move: function(x, y)
          {
            this.grid.position.x += x;
            while((this.grid.position.x - view.bounds.center.x) >= 200)
            {
              this.grid.position.x -= 200;
            }
            while((this.grid.position.x - view.bounds.center.x) <= -200)
            {
              this.grid.position.x += 200;
            }
            this.grid.position.y += y;
            while((this.grid.position.y - view.bounds.center.y) >= 200)
            {
              this.grid.position.y -= 200;
            }
            while((this.grid.position.y - view.bounds.center.y) <= -200)
            {
              this.grid.position.y += 200;
            }

            this.path.position.x += x;
            this.path.position.y += y;
          },

          intersects: function(path)
          {
            if(this.path.visible === false)
            {
              return(false);
            }
            return(this.path.intersects(path));
          },

          contains: function(point)
          {
            if(this.path.visible === false)
            {
              return(false);
            }
            return(this.path.contains(point));
          }
        };
      };

      var Robot = new function()
      {
        var robot = assets.robot.clone();
        robot.visible = true;
        robot.position = view.bounds.center;
        robot.bringToFront();

        return {
          robot: robot,
          angle: 0,
          error: 0,
          steer: 0,
          sensor: 0,
          drift: 0,
          count: 0,

          reset: function()
          {
            this.robot.visible = false;
            this.robot = assets.robot.clone();
            this.robot.visible = true;
            this.robot.bringToFront();
            this.robot.position = view.bounds.center;
            this.angle = 0;
            this.drift = 0.025 - (0.05 * Math.random());
            this.updateSensor();
          },

          position: function()
          {
            return(this.robot.position);
          },

          resize: function()
          {
            this.robot.position = view.bounds.center;
          },

          rotate: function(angle)
          {
            this.robot.rotate(angle);
            this.angle += angle;
          },

          updateSensor: function()
          {
            if(globals.mode === "gyro")
            {
              this.sensor = Math.round(this.angle, 0);
            }
            else
            {
              this.sensor = (globals.sensor == 0) ? this.getLeft() :
                                                    this.getRight();
            }
          },

          update: function()
          {
            this.count++;
            if(this.count <= 5)
            {
              return;
            }
            this.count = 0;

            var value = this.sensor;

            if(globals.mode === "line")
            {
              this.error = value - 50;
              this.steer = this.error * globals.kp;
            }
            else if(globals.mode === "line2")
            {
              if(value < 50)
              {
                this.steer = -globals.max_steer / 2;
              }
              else
              {
                this.steer = globals.max_steer / 2;
              }
            }
            else if(globals.mode === "line3")
            {
              if((value >= 40) && (value <= 60))
              {
                this.steer = 0;
              }
              else if(value < 50)
              {
                this.steer = -globals.max_steer / 2;
              }
              else
              {
                this.steer = globals.max_steer / 2;
              }
            }
            else if(globals.mode === "gyro")
            {
              this.error = value - globals.heading;
              this.steer = this.error * globals.kp;
            }
            else
            {
              this.error = 0;
              this.steer = globals.steer;
            }

            if(this.steer > globals.max_steer)
            {
              this.steer = globals.max_steer;
            }
            if(this.steer < -globals.max_steer)
            {
              this.steer = -globals.max_steer;
            }
          },

          step: function()
          {
            var w, s, Di, Dm, Do, pt, a;

            Graph.addSample(this.angle, this.error, this.steer);

            w = 100;

            s = ((globals.max_steer - (Math.abs(this.steer) * 2)) /
                 globals.max_steer);

            if(s == 1)
            {
              pt = new Point(0, globals.power / 10);
              a = 0;
            }
            else
            {
              Di = (2 * s * w) / (1 - s);
              Dm = Di + w;
              Do = Di + (2 * w);

              a = 360 * (globals.power / 10) / (Do * Math.PI);

              Dm /= 2;

              pt = new Point(Dm - (Dm * Math.cos(a * Math.PI / 180)),
                             Dm * Math.sin(a * Math.PI / 180));
              if(this.steer < 0)
              {
                pt.x *= -1;
                a *= -1;
              }
            }

            pt = pt.rotate(this.drift);
            a += this.drift;

            pt = pt.rotate(this.angle);
            Field.move(pt.x, pt.y);
            this.rotate(a);
            this.updateSensor();
          },

          readSensor: function(pos)
          {
            var on = 0;
            var count = 0;

            for(var y = -10; y <= 10; y++)
            {
              for(var x = -10; x <= 10; x++)
              {
                if(((x * x) + (y * y)) <= 100)
                {
                  if(Field.contains(pos + [x, y]) == true)
                  {
                    on++;
                  }
                  count++;
                }
              }
            }

            return(Math.floor(((count - on) * 100) / count));
          },

          getLeft: function()
          {
            return(this.readSensor(this.robot.children[3].position));
          },

          setLeft: function(intensity)
          {
            this.robot.children[3].fillColor = new Color(intensity / 100,
                                                         intensity / 100,
                                                         intensity / 100);
          },

          getRight: function()
          {
            return(this.readSensor(this.robot.children[4].position));
          },

          setRight: function(intensity)
          {
            this.robot.children[4].fillColor = new Color(intensity / 100,
                                                         intensity / 100,
                                                         intensity / 100);
          },

          getAngle: function()
          {
              return(Math.round(this.angle));
          },

          getError: function()
          {
            return(this.error);
          },

          getSteer: function()
          {
            return(this.steer);
          }
        };
      };

      var Display = new function()
      {
        return {
          update: function()
          {
            var elem;
            var intensity;

            intensity = Robot.getLeft();
            Robot.setLeft(intensity);
            $("#sensor_left").html(intensity);
            intensity = (255 * intensity) / 100;
            $("#sensor_left_color").css("background-color",
                                        "rgb(" + intensity + ", " + intensity +
                                        ", " + intensity + ")");

            intensity = Robot.getRight();
            Robot.setRight(intensity);
            $("#sensor_right").html(intensity);
            intensity = (255 * intensity) / 100;
            $("#sensor_right_color").css("background-color",
                                         "rgb(" + intensity + ", " +
                                         intensity + ", " + intensity + ")");

            $("#sensor_gyro").html(Math.round(Robot.getAngle() * 100) / 100);

            $("#error").html(Math.round(Robot.getError() * 100) / 100);

            $("#steerOut").html(Math.round(Robot.getSteer() * 100) / 100);
          }
        };
      };

      var Graph = new function()
      {
        var angleGraph = (new Project("angleGraph")).activeLayer;
        var errorGraph = (new Project("errorGraph")).activeLayer;
        var steerGraph = (new Project("steerGraph")).activeLayer;

        return {
          angleGraph: angleGraph,
          errorGraph: errorGraph,
          steerGraph: steerGraph,
          angle: [],
          error: [],
          steer: [],
          step: 0,

          draw: function(width, height, range, data)
          {
            var g, a, d, i, x, y;

            g = new Group();

            for(i = 0; i < 5; i++)
            {
              a = new Path();
              a.moveTo(new Point(0, (i * height) / 4));
              a.lineTo(new Point(width, (i * height) / 4));
              a.strokeColor = "#cccccc";
              g.addChild(a);
            }

            for(i = 0; i < 7; i++)
            {
              a = new Path();
              a.moveTo(new Point((i * width) / 6, 0));
              a.lineTo(new Point((i * width) / 6, height));
              a.strokeColor = "#cccccc";
              g.addChild(a);
            }

            a = new CompoundPath();

            for(i = 0; i < data.length; i++)
            {
              d = data[data.length - i - 1];

              x = (((30 * 60) - i) * width) / (30 * 60);
              y = ((d + range) * height) / (range * 2);

              if((i == 0) ||
                 ((d > (range - 20)) &&
                  (data[data.length - i] < (20 - range))) ||
                 ((d < (20 - range)) &&
                  (data[data.length - i] > (range - 20))))
              {
                a.moveTo(new Point(x, y));
              }
              else
              {
                a.lineTo(new Point(x, y));
              }
            }

            a.strokeColor = "black";

            g.addChild(a);

            a = new PointText(new Point(0, 10));
            a.content = range;
            a.strokeColor = "#4285f4";
            a.fillColor = "#4285f4";

            g.addChild(a);

            a = new PointText(new Point(0, (height / 2) + 5));
            a.content = 0;
            a.strokeColor = "#4285f4";
            a.fillColor = "#4285f4";

            g.addChild(a);

            a = new PointText(new Point(0, height - 1));
            a.content = -range;
            a.strokeColor = "#4285f4";
            a.fillColor = "#4285f4";

            g.addChild(a);

            return(g);
          },

          drawAngle: function()
          {
            var p;

            p = this.draw(this.angleGraph.view.bounds.width - 1,
                          this.angleGraph.view.bounds.height - 1, 180,
                          this.angle);

            this.angleGraph.removeChildren();
            this.angleGraph.addChild(p);
          },

          drawError: function()
          {
            var p;

            p = this.draw(this.errorGraph.view.bounds.width - 1,
                          this.errorGraph.view.bounds.height - 1, 100,
                          this.error);

            this.errorGraph.removeChildren();
            this.errorGraph.addChild(p);
          },

          drawSteer: function()
          {
            var p;

            p = this.draw(this.steerGraph.view.bounds.width - 1,
                          this.steerGraph.view.bounds.height - 1,
                          globals.max_steer, this.steer);

            this.steerGraph.removeChildren();
            this.steerGraph.addChild(p);
          },

          resize: function()
          {
            globals.redraw = true;
          },

          reset: function()
          {
            this.angle = [];
            this.error = [];
            this.steer = [];

            this.drawAngle();
            this.drawError();
            this.drawSteer();
          },

          addSample: function(angle, error, steer)
          {
            while(angle > 180)
            {
              angle -= 360;
            }
            while(angle <= -180)
            {
              angle += 360;
            }
            this.angle.push(0 - angle);
            while(this.angle.length > (30 * 60))
            {
              this.angle.shift();
            }

            this.error.push(0 - error);
            while(this.error.length > (30 * 60))
            {
              this.error.shift();
            }

            this.steer.push(0 - steer);
            while(this.steer.length > (30 * 60))
            {
              this.steer.shift();
            }

            this.drawAngle();
            this.drawError();
            this.drawSteer();
          }
        };
      };

      function onFrame()
      {
        if(globals.reset == true)
        {
          Field.reset();
          Robot.reset();
          Robot.update();
          Display.update();
          Graph.reset();
          globals.run = false;
          globals.reset = false;
          globals.random = false;
          globals.nudge = false;
          globals.update = false;
        }
        if(globals.random == true)
        {
          Field.reset();
          if((globals.mode === "line") || (globals.mode === "line2") ||
             (globals.mode === "line3"))
          {
            Field.move(10 - Math.floor(20 * Math.random()), 0);
          }
          Robot.reset();
          if((globals.mode === "line") || (globals.mode === "line2") ||
             (globals.mode === "line3"))
          {
            Robot.rotate(15 - (30 * Math.random()));
          }
          else if(globals.mode === "gyro")
          {
            Robot.rotate(30 - (60 * Math.random()));
          }
          Robot.updateSensor();
          Robot.update();
          Display.update();
          Graph.reset();
          globals.run = false;
          globals.reset = false;
          globals.random = false;
          globals.update = false;
        }
        if(globals.nudge == true)
        {
          if((globals.mode === "line") || (globals.mode === "line2") ||
             (globals.mode === "line3"))
          {
            Robot.rotate(15 - (30 * Math.random()));
          }
          else
          {
            Robot.rotate(30 - (60 * Math.random()));
          }
          globals.nudge = false;
        }
        if((globals.run == true) || (globals.step == true))
        {
          Robot.step();
          Robot.update();
          Display.update();
          globals.step = false;
          globals.update = false;
        }
        if(globals.update == true)
        {
          Robot.update();
          Display.update();
          globals.update = false;
        }
        if(globals.redraw == true)
        {
          Graph.drawAngle();
          Graph.drawError();
          Graph.drawSteer();
          globals.redraw = false;
        }
      }

      function onResize(event)
      {
        Field.resize();
        Robot.resize();
        Graph.resize();
      }

      function onKeyUp(event)
      {
        if(event.key === "space")
        {
          var button = $("#play i");

          if(button.hasClass("fa-pause"))
          {
            button.removeClass("fa-pause");
            button.addClass("fa-play");
          }
          else
          {
            button.removeClass("fa-play");
            button.addClass("fa-pause");
          }

          globals.run = !globals.run;
        }

        if(event.key === "r")
        {
          var button = $("#play i");

          if(button.hasClass("fa-pause"))
          {
            button.removeClass("fa-pause");
            button.addClass("fa-play");
          }

          globals.run = false;
          globals.reset = true;
        }

        if(event.key === "s")
        {
          globals.step = true;
        }

        if(event.key === "!")
        {
          var button = $("#play i");

          if(button.hasClass("fa-pause"))
          {
            button.removeClass("fa-pause");
            button.addClass("fa-play");
          }

          globals.run = false;
          globals.random = true;
        }

        if(event.key === "escape")
        {
          closeHelp();
        }
      }
    </script>
    <script type="text/javascript">
      window.globals =
      {
        mode: 0,
        sensor: 0,
        power: 30,
        steer: 0,
        max_steer: 100,
        heading: 0,
        kp: 0,
        update: false,
        redraw: false,
        run: false,
        step: false,
        reset: true,
        random: false
      };

      function
      modeChange()
      {
        var button = $("#play i");

        if(button.hasClass("fa-pause"))
        {
          button.removeClass("fa-pause");
          button.addClass("fa-play");
        }

        globals.run = false;
        globals.step = false;
        globals.reset = true;
      }

      function
      modeOpen()
      {
        var title = "Open Loop";

        $("title").text(title);
        $(".header > p").text(title);

        $(".footer > p").text("Open loop mode does not use any sensors.");

        $(".showLine2").hide();
        $(".showLine3").hide();
        $(".showLine").hide();
        $(".showGyro").hide();
        $(".showOpen").show();
        globals.mode = "open";
        modeChange();
      }

      function
      modeLine2()
      {
        var title = "Line Following (2-stage)";

        $("title").text(title);
        $(".header > p").text(title);

        $(".footer > p").text("A 2-stage line follower pivots left or right " +
                              "based on the light sensor.");

        $(".showOpen").hide();
        $(".showLine3").hide();
        $(".showLine").hide();
        $(".showGyro").hide();
        $(".showLine2").show();
        globals.mode = "line2";
        modeChange();
      }

      function
      modeLine3()
      {
        var title = "Line Following (3-stage)";

        $("title").text(title);
        $(".header > p").text(title);

        $(".footer > p").text("A 3-stage line follower pivots left, drives " +
                              "straight, or pivots right based on the light " +
                              "sensor.");

        $(".showOpen").hide();
        $(".showLine2").hide();
        $(".showLine").hide();
        $(".showGyro").hide();
        $(".showLine3").show();
        globals.mode = "line3";
        modeChange();
      }

      function
      modeLine()
      {
        var title = "Line Following (Proportional)";

        $("title").text(title);
        $(".header > p").text(title);

        $(".footer > p").text("A proportional line follower steers back to " +
                              "the edge of the line at a rate corresponding " +
                              "to the amount of error.");

        $(".showOpen").hide();
        $(".showLine2").hide();
        $(".showLine3").hide();
        $(".showGyro").hide();
        $(".showLine").show();
        globals.mode = "line";
        modeChange();
      }

      function
      modeGyro()
      {
        var title = "Gyro Driving";

        $("title").text(title);
        $(".header > p").text(title);

        $(".footer > p").text("Gyro driving 'follows' an imaginary line by " +
                              "maintaining a given heading.");

        $(".showOpen").hide();
        $(".showLine2").hide();
        $(".showLine3").hide();
        $(".showLine").hide();
        $(".showGyro").show();
        globals.mode = "gyro";
        modeChange();
      }

      function
      changeMode(evt)
      {
        var select = $(evt.target);
        switch(select.val())
        {
          case "open":
          default:
          {
            modeOpen();
            break;
          }

          case "line2":
          {
            modeLine2();
            break;
          }

          case "line3":
          {
            modeLine3();
            break;
          }

          case "line":
          {
            modeLine();
            break;
          }

          case "gyro":
          {
            modeGyro();
            break;
          }
        }
      }

      function
      switchSensor(evt)
      {
        var button = $(evt.target);
        if(button.is("button"))
        {
          button = button.children().first();
        }
        if(button.hasClass("fa-arrow-left"))
        {
          button.removeClass("fa-arrow-left");
          button.addClass("fa-arrow-right");
          window.globals.sensor = 1;
        }
        else
        {
          button.removeClass("fa-arrow-right");
          button.addClass("fa-arrow-left");
          window.globals.sensor = 0;
        }
        window.globals.update = true;
      }

      function
      updatePower(evt)
      {
        var input = $(evt.target);
        var power = parseFloat(input[0].value);
        if(isNaN(power))
        {
          power = 0;
        }
        if(power > 100)
        {
          input[0].value = 100;
          power = 100;
        }
        if(power < -100)
        {
          input[0].value = -100;
          power = -100;
        }
        window.globals.power = power;
        window.globals.update = true;
      }

      function
      updateSteer(evt)
      {
        var input = $(evt.target);
        var steer = parseFloat(input[0].value);
        if(isNaN(steer))
        {
          steer = 0;
        }
        if(steer > globals.max_steer)
        {
          input[0].value = globals.max_steer;
          steer = globals.max_steer;
        }
        if(steer < -globals.max_steer)
        {
          input[0].value = -globals.max_steer;
          steer = -globals.max_steer;
        }
        window.globals.steer = steer;
        window.globals.update = true;
      }

      function
      updateHeading(evt)
      {
        var input = $(evt.target);
        var heading = parseFloat(input[0].value);
        if(isNaN(heading))
        {
          heading = 0;
        }
        window.globals.heading = heading;
        window.globals.update = true;
      }

      function
      updateKp(evt)
      {
        var input = $(evt.target);
        if(input[0].value !== "")
        {
          window.globals.kp = parseFloat(input[0].value);
          if(isNaN(window.globals.kp))
          {
            window.globals.kp = 0;
          }
          window.globals.update = true;
        }
      }

      function
      pressPlayPause(evt)
      {
        var button = $(evt.target);
        if(button.is("button"))
        {
          button = button.children().first();
        }
        if(button.hasClass("fa-play"))
        {
          button.removeClass("fa-play");
          button.addClass("fa-pause");
          window.globals.run = true;
        }
        else
        {
          button.removeClass("fa-pause");
          button.addClass("fa-play");
          window.globals.run = false;
        }
      }

      function
      pressStep(evt)
      {
        window.globals.step = true;
      }

      function
      pressReset(evt)
      {
        var button = $("#play i");

        if(button.hasClass("fa-pause"))
        {
          button.removeClass("fa-pause");
          button.addClass("fa-play");
        }

        window.globals.run = false;
        window.globals.reset = true;
      }

      function
      pressRandom(evt)
      {
        var button = $("#play i");

        if(button.hasClass("fa-pause"))
        {
          button.removeClass("fa-pause");
          button.addClass("fa-play");
        }

        window.globals.run = false;
        window.globals.random = true;
      }

      function
      pressNudge(evt)
      {
        window.globals.nudge = true;
      }

      function
      help()
      {
        var button = $("#play i");

        if(button.hasClass("fa-pause"))
        {
          button.removeClass("fa-pause");
          button.addClass("fa-play");
        }

        globals.run = false;

        if(globals.mode == "open")
        {
          $("#help_open").show();
        }
        else if(globals.mode == "line2")
        {
          $("#help_2stage").show();
        }
        else if(globals.mode == "line3")
        {
          $("#help_3stage").show();
        }
        else if(globals.mode == "line")
        {
          $("#help_proportional").show();
        }
        else if(globals.mode == "gyro")
        {
          $("#help_gyro").show();
        }
      }

      function
      closeHelp()
      {
        $(".overlay").hide();
      }

      function
      load()
      {
        modeOpen();
        $(".full-screen").css("display", "flex");
        window.dispatchEvent(new Event('resize'));
      }

      function
      toggleFullscreen(e)
      {
        if(((e.key == 'f') || (e.key == 'F')) && (e.ctrlKey == true))
        {
          if(!document.fullscreenElement)
          {
            document.documentElement.requestFullscreen();
          }
          else
          {
            document.exitFullscreen();
          }

          e.stopPropagation();
        }
      }

      $(window).on("load", load);
      $(window).on("keydown", toggleFullscreen);
    </script>
    <style type="text/css">
      html, body, .full-screen
      {
        height: 100%;
        width: 100%;
      }

      body
      {
        background: white;
        font-family: Helvetica, Arial;
        margin: 0;
      }

      .full-screen
      {
        display: none;
        flex-direction: column;
        overflow: hidden;
        position: fixed;
      }

      .full-screen > .header
      {
        background-color: #4285f4;
        color: white;
        flex: none;
        font-size: larger;
        font-weight: bold;
        overflow: scroll;
        text-align: center;
        text-shadow: 1px 1px black;
      }

      .full-screen > .footer
      {
        background-color: #4285f4;
        color: white;
        flex: none;
        overflow: scroll;
        padding-left: 1em;
        padding-right: 1em;
      }

      .full-screen > .main
      {
        display: flex;
        flex: auto;
        flex-direction: row;
        overflow: hidden;
      }

      .full-screen > .main > .left
      {
        background: white;
        border-right: 1px solid black;
        flex: none;
        overflow: scroll;
        padding: 5px;
        width: 20%;
      }

      .full-screen > .main > .middle
      {
        flex: auto;
        width: 1%;
      }

      .full-screen > .main > .right
      {
        background: white;
        border-left: 1px solid black;
        flex: none;
        overflow: scroll;
        padding: 5px;
        width: 20%;
      }

      .center
      {
        text-align: center;
      }

      .hidden
      {
        display: none;
      }

      .overlay
      {
        height: 100%;
        left: 0;
        position: fixed;
        top: 0;
        width: 100%;
      }

      .shadow
      {
        background-color: #000;
        height: 100%;
        left: 0;
        opacity: 25%;
        position: fixed;
        top: 0;
        width: 100%;
        z-index: 100;
      }

      .insert
      {
        background-color: #fff;
        border-radius: 20px;
        height: calc(100vh - 10vw);
        left: calc(5vw - 20px);
        overflow-y: scroll;
        padding: 20px 20px;
        position: fixed;
        top: calc(5vw - 20px);
        width: 90vw;
        z-index: 101;
      }

      .insert > div
      {
        height: calc(100vh - 10vw);
        overflow-y: scroll;
      }

      .help
      {
        background-color: #4285f4;
        border-color: #fff;
        border-radius: 5px;
        border-width: 2px;
        color: #fff;
        float: right;
        margin: 10px 0px;
        padding: 5px 20px;
      }

      h1
      {
        font-size: 1.5em;
        font-weight: bold;
        margin-block-end: 0.75em;
        margin-block-start: 0em;
      }

      hr
      {
        margin-block-end: 1em;
        margin-block-start: 1em;
      }

      #sensor_left
      {
        display: inline-block;
        text-align: center;
        width: 2em;
      }

      #sensor_left_color
      {
        background-color: white;
        border: 1px solid black;
        display: inline-block;
        height: 20px;
        vertical-align: middle;
        width: 20px;
      }

      #sensor_right
      {
        display: inline-block;
        text-align: center;
        width: 2em;
      }

      #sensor_right_color
      {
        background-color: white;
        border: 1px solid black;
        display: inline-block;
        height: 20px;
        vertical-align: middle;
        width: 20px;
      }

      #sensor_gyro
      {
        display: inline-block;
        text-align: center;
        width: 2em;
      }

      #error
      {
        display: inline-block;
        text-align: center;
        width: 2em;
      }

      #steerOut
      {
        display: inline-block;
        text-align: center;
        width: 2em;
      }

      #angleGraph
      {
        height: 18vh;
        width: 100%;
      }

      #errorGraph
      {
        height: 18vh;
        width: 100%;
      }

      #steerGraph
      {
        height: 18vh;
        width: 100%;
      }

      .control
      {
        height: 36px;
        width: 46px;
      }
    </style>
  </head>
  <body>
    <div class="full-screen">
      <div class="header">
        <p>
          &nbsp;
        </p>
        <a href="https://github.com/bckircher/RobotSim" target="_blank">
          <img style="position: absolute; right: 0; top: 0" decoding="async"
               width="124" height="124"
               src="https://github.blog/wp-content/uploads/2008/12/forkme_right_white_ffffff.png"
               class="attachment-full size-full" alt="Fork me on GitHub"
               loading="lazy">
        </a>
      </div>
      <div class="main">
        <div class="left center">
          <h1>
            Mode
          </h1>
          <label for="mode">Mode:</label>
          <select id="mode" onchange="changeMode(event);">
            <option value="open">Open Loop</option>
            <option value="line2">Line Following (2-stage)</option>
            <option value="line3">Line Following (3-stage)</option>
            <option value="line">Line Following (Proportional)</option>
            <option value="gyro">Gyro Driving</option>
          </select>
          <hr>
          <h1>
            Inputs
          </h1>
          <table>
            <tr class="showLine showLine2 showLine3">
              <td>
                Sensor:
              </td>
              <td>
                <button onclick="switchSensor(event);">
                  <i class="fa fa-arrow-left fa-2x"></i>
                </button>
              </td>
            </tr>
            <tr class="showLine showLine2 showLine3">
              <td colspan=2>
                <small>
                  <em>
                    Which sensor the robot uses to follow the line.
                  </em>
                </small>
              </td>
            </tr>
            <tr class="showLine showLine2 showLine3">
              <td>
                &nbsp;
              </td>
            </tr>
            <tr>
              <td>
                Power:
              </td>
              <td>
                <input id="power" type="text" pattern="[0-9]*" size="8"
                       value="30" onchange="updatePower(event);" />
              </td>
            </tr>
            <tr>
              <td colspan=2>
                <small>
                  <em>
                    How fast the robot moves.
                  </em>
                </small>
              </td>
            </tr>
            <tr class="showOpen">
              <td>
                &nbsp;
              </td>
            </tr>
            <tr class="showOpen">
              <td>
                Steering:
              </td>
              <td>
                <input id="steerIn" type="text" pattern="[0-9]*" size="8"
                       value="0" onchange="updateSteer(event);" />
              </td>
            </tr>
            <tr class="showOpen">
              <td colspan=2>
                <small>
                  <em>
                    The direction the robot moves.
                  </em>
                </small>
              </td>
            </tr>
            <tr class="showGyro">
              <td>
                &nbsp;
              </td>
            </tr>
            <tr class="showGyro">
              <td>
                Heading:
              </td>
              <td>
                <input id="heading" type="text" pattern="[0-9.]*" size="8"
                       value="0" onchange="updateHeading(event);" />
              </td>
            </tr>
            <tr class="showGyro">
              <td colspan=2>
                <small>
                  <em>
                    The direction the robot travels.
                  </em>
                </small>
              </td>
            </tr>
            <tr class="showLine showGyro">
              <td>
                &nbsp;
              </td>
            </tr>
            <tr class="showLine showGyro">
              <td>
                Kp:
              </td>
              <td>
                <input id="kp" type="text" pattern="[0-9.]*" size="8"
                       value="0" onchange="updateKp(event);" />
              </td>
            </tr>
            <tr class="showLine showGyro">
              <td colspan=2>
                <small>
                  <em>
                    How quickly the robot responds to error.
                  </em>
                </small>
              </td>
            </tr>
          </table>
          <hr>
          <h1 class="showLine showLine2 showLine3 showGyro">
            What the robot sees
          </h1>
          <table class="showLine showLine2 showLine3 showGyro">
            <tr class="showLine showLine2 showLine3">
              <td>
                Left sensor:
              </td>
              <td>
                <span id="sensor_left">0</span>
                <span id="sensor_left_color"></span>
              </td>
            </tr>
            <tr class="showLine showLine2 showLine3">
              <td>
                Right sensor:
              </td>
              <td>
                <span id="sensor_right">0</span>
                <span id="sensor_right_color"></span>
              </td>
            </tr>
            <tr class="showGyro">
              <td>
                Gyro sensor:
              </td>
              <td>
                <span id="sensor_gyro">0</span>
              </td>
            </tr>
          </table>
          <hr class="showLine showLine2 showLine3 showGyro">
          <h1 class="showLine showLine2 showLine3 showGyro">
            What the robot decides
          </h1>
          <table class="showLine showLine2 showLine3 showGyro">
            <tr class="showLine showGyro">
              <td>
                Error:
              </td>
              <td>
                <span id="error">0</span>
              </td>
            </tr>
            <tr>
              <td colspan=2>
                <small>
                  <em class="showLine">
                    error = reading - 50
                  </em>
                  <em class="showGyro">
                    error = reading - heading
                  </em>
                </small>
              </td>
            </tr>
            <tr class="showLine showGyro">
              <td>
                &nbsp;
              </td>
            </tr>
            <tr>
              <td>
                Steering:
              </td>
              <td>
                <span id="steerOut">0</span>
              </td>
            </tr>
            <tr class="showLine showGyro">
              <td colspan=2>
                <small>
                  <em>
                    steering = error * Kp
                  </em>
                </small>
              </td>
            </tr>
          </table>
          <hr class="showLine showLine2 showLine3 showGyro">
          <h1>
            Controls
          </h1>
          <p class="center">
            <button id="play" class="control"
                    onclick="pressPlayPause(event);">
              <i class="fa fa-play fa-2x"></i>
            </button>
            <button class="control showLine showLine2 showLine3 showGyro"
                    onclick="pressStep(event);">
              <i class="fa fa-step-forward fa-2x"></i>
            </button>
            <button class="control" onclick="pressReset(event);">
              <i class="fa fa-refresh fa-2x"></i>
            </button>
            <button class="control showLine showLine2 showLine3 showGyro"
                    onclick="pressRandom(event);">
              <i class="fa fa-random fa-2x"></i>
            </button>
            <button class="control" onclick="pressNudge(event)">
              <i class="fa fa-superpowers fa-2x"></i>
            </button>
          </p>
        </div>
        <canvas id="canvas" class="middle" resize></canvas>
        <div class="right center">
          <h2>
            Angle
          </h2>
          <canvas id="angleGraph" resize></canvas>
          <h2>
            Error
          </h2>
          <canvas id="errorGraph" resize></canvas>
          <h2>
            Steering
          </h2>
          <canvas id="steerGraph" resize></canvas>
        </div>
      </div>
      <div class="footer">
        <button class="help" onclick="help();">Help</button>
        <p></p>
      </div>
    </div>
    <div id="help_open" class="overlay" style="display: none;">
      <div class="shadow" onclick="closeHelp();"></div>
      <div class="insert">
        <div>
        <h2>
          Open Loop
        </h2>
        <p>
          In open loop mode, the robot simply drives forward. It does not
          adjust its direction of travel based on any sensors and therefore
          does not correct for any errors in its direction of travel. This is
          used by many teams in FLL-C, and can be a very effective technique
          when used for traveling short distances.
        </p>
        <p>
          When running in this mode for any period of time, you may notice that
          the robot drifts to the left or the right. On a real robot, the
          diameter of the wheels won't be exactly the same, the speed of the
          two motors won't be exactly the same, and so on. This results in the
          drift that is simulated here. This demonstrates why it is
          advantageous to use a more advanced driving method, especially over
          longer distances.
        </p>
        <p>
          In EV3 Classroom, this program looks like the following:
        </p>
        <img type="image/png" src="images/open_loop.png" />
        <p>
          Of course, the steering value might be different if the direction of
          travel is something other than straight ahead.
        </p>
        </div>
      </div>
    </div>
    <div id="help_2stage" class="overlay" style="display: none;">
      <div class="shadow" onclick="closeHelp();"></div>
      <div class="insert">
        <h2>
          Line Following (2-stage)
        </h2>
        <p>
          The two-stage line follower allows the robot to use a color sensor in
          reflected light intensity mode in order to follow the path of a line.
          To be more precise, it follows the edge of the line, where there is a
          high contrast on the mat (between the dark-colored line and the
          light-colored area surrouding it).
        </p>
        <p>
          It is known as a two-stage follower because it does one of two
          things; it veers to the left or to the right, based on what the
          sensor sees. Take for example the left edge of the line being
          followed; when the sensor sees more white than black, the robot
          veers to the right (towards the edge of the line), and hwne it sees
          more black than white, it feers to the left (again, towards the edge
          of the line).
        </p>
        <p>
          In EV3 Classroom, this program looks like the following:
        </p>
        <img type="image/png" src="images/two_stage.png" />
        <p>
          The steering of 50 and -50 controls how quickly the robot reacts to
          not seeing the edge of the line. Using less agressive steering values
          (such as 30 and -30) allows the robot to progress down the line
          faster but makes it less responsive to bends/curves in the line.
        </p>
        <p>
          By swapping the 50 and -50 values, the robot follows the opposite
          side of the line.
        </p>
        <p>
          While simple and easy to understand, the big disadvantage to a
          two-stage line follower is the rate at which the robot heading
          wildly swings back and forth. After the robot has traveled the
          desired distance (be it wheel rotations, another sensor seeing
          something, etc.), it is difficult to predict the direction that the
          robot is facing. So, while it has followed the line to a new
          location, the heading is uncontrolled.
        </p>
      </div>
    </div>
    <div id="help_3stage" class="overlay" style="display: none;">
      <div class="shadow" onclick="closeHelp();"></div>
      <div class="insert">
        <h2>
          Line Following (3-stage)
        </h2>
        <p>
          The three-stage line follower is a minor extension of the two-stage
          line follower. As is implied, there is a third decision that it can
          make; if the reflected light intensity is "close enough" to 50 (the
          edge of the line), the robot simply drives straight.
        </p>
        <p>
          With this modification, the robot is generally able to travel along
          the line faster than with a two-stage line follower (since there are
          periods of time where it is driving straight). However, it still
          suffers from the same disadvantage as the two-stage line follower.
        </p>
        <p>
          In EV3 Classroom, this program looks like the following:
        </p>
        <img type="image/png" src="images/three_stage.png" />
      </div>
    </div>
    <div id="help_proportional" class="overlay" style="display: none;">
      <div class="shadow" onclick="closeHelp();"></div>
      <div class="insert">
        <h2>
          Line Following (Proportional)
        </h2>
        <p>
          The proportional line follower is more complex in concept, simpler in
          implementation, but requires more involved tuning to make it work
          well (there is no "one size fits all" tuning for a proportional
          line follower, the tuning tends to be unique to each robot design).
        </p>
        <p>
          The algorithm starts by taking a reflected light intensity reading
          and subtracting it from 50 (the desired value). The difference is
          known as the <i>error</i>, i.e. how far the robot is from the desired
          location. The <i>error</i> is multiplied by a factor known as
          <i>kP</i>, which controls how quickly the robot responds to being
          away from the edge of the line. The resulting values is applied to
          the robot as the steering value.
        </p>
        <p>
          This algorithm mimics the behavior of humans. When walking along a
          line, humans will gently turn back toward the line if they stray off
          the line by a small amount. However, it they will aggressively turn
          back toward the line if they stray off by a large amount. In the same
          manner, a small <i>error</i> multipled by <i>kP</i> results in a
          small steering value, while a large <i>error</i> multipled by
          <i>kP</i> results in a large steering value, just like a human.
        </p>
        <p>
          In EV3 Classroom, this program looks like the following:
        </p>
        <img type="image/png" src="images/proportional.png" />
        <p>
          Having this program and tuning it are very different things! For
          advanced control algorithms (such as this), it is typical that
          implementing the algoritm is rather easy but tuning it to work well
          on a robot is not as straightforward. The general process is to
          choose a value for <i>kP</i> (typically 1 is a good starting point)
          and see how the robot behaves. If it is too slow to respond to the
          line, double the value of <i>kP</i>; if it reponds too quickly
          (usually by waddling back and forth like a two-stage line follower),
          half the value of <i>kP</i>. Repeat this process until <i>kP</i>
          makes the robot respond in a reasonable fashion, or there are two
          choices that are on either side (one is a bit too slow and one is a
          bit too fast); try value of <i>kP</i> between those two to find one
          that gives the desired behavior.
        </p>
        <p>
          Note that a good value of <i>kP</i> is dependent upon the speed of
          the robot. If the robot goes faster, <i>kP</i> needs to increase so
          that the robot responds to the line quicker (since the robot, and by
          extension the line, is moving quicker). Similarly, if the robot goes
          slower, <i>kP</i> needs to decrease for the same reason.
        </p>
      </div>
    </div>
    <div id="help_gyro" class="overlay" style="display: none;">
      <div class="shadow" onclick="closeHelp();"></div>
      <div class="insert">
        <h2>
          Gyro Driving
        </h2>
        <p>
          Using a gyro to drive straight can be thought of as having the robot
          follow an imaginary line. Where a real line doesn't exist on the mat,
          the robot can follow an imaginary one created by the gyro!
        </p>
        <p>
          While any of the previous algorithms (two-stage, three-stage, and
          proportional) can be used to drive straight with the gyro, it is best
          to implement the proportional algorithm (really, adapt it to the gyro
          instead of the light sensor). There are two differences; the gyro
          angle is read instead of the reflected light intensity, and the
          target value is the angle that the robot should drive instead of the
          <i>50</i> value for the edge of the line. The algorithm is otherwise
          the same.
        </p>
        <p>
          In EV3 Classroom, this program looks like the following:
        </p>
        <img type="image/png" src="images/gyro.png" />
        <p>
          Like the proportional line follower, the <i>kP</i> value must be
          tuned. However, the <i>kP</i> value that works for a proportional
          line follower will not be the same as the <i>kP</i> that is used for
          a drive straight with the gyro. This is because each sensor returns a
          different value, that changes at a different rate as the robot moves.
          The tuning process is exactly the same though.
        </p>
        <p>
          What is sometimes helpful when tuning the drive straight with the
          gyro algorithm is to nudge the robot off course and see how well and
          how quickly it corrects itself. This often makes it easier to see how
          the robot behaves and responds to the <i>kP</i> value that is being
          tested.
        </p>
        <p>
          Depending on how the gyro is mounted (upside down versus right-side
          up), a positive change in the gyro angle may require a positive or
          negative turn direction for the robot (to get it back to the
          imaginary line). If the turn direction is the opposite of the gyro
          angle change, having a positive <i>kP</i> value causes the robot to
          spin wildly (because the "correction" makes the problem worse!). If
          the robot spins in circles forever, this is the reason. It is simple
          to fix; simply use a negative value for <i>kP</i>.
        </p>
      </div>
    </div>
  </body>
</html>